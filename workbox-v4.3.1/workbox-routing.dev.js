this.workbox=this.workbox||{},this.workbox.routing=function(l,c,n,x,m,R){"use strict";try{self["workbox:routing:4.3.1"]&&_()}catch{}const y="GET",E=["DELETE","GET","HEAD","PATCH","POST","PUT"],N=o=>o&&typeof o=="object"?(c.assert.hasMethod(o,"handle",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),o):(c.assert.isType(o,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"handler"}),{handle:o});class g{constructor(e,r,t){c.assert.isType(e,"function",{moduleName:"workbox-routing",className:"Route",funcName:"constructor",paramName:"match"}),t&&c.assert.isOneOf(t,E,{paramName:"method"}),this.handler=N(r),this.match=e,this.method=t||y}}class w extends g{constructor(e,{whitelist:r=[/./],blacklist:t=[]}={}){c.assert.isArrayOfClass(r,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.whitelist"}),c.assert.isArrayOfClass(t,RegExp,{moduleName:"workbox-routing",className:"NavigationRoute",funcName:"constructor",paramName:"options.blacklist"}),super(a=>this._match(a),e),this._whitelist=r,this._blacklist=t}_match({url:e,request:r}){if(r.mode!=="navigate")return!1;const t=e.pathname+e.search;for(const a of this._blacklist)if(a.test(t))return n.logger.log(`The navigation route is not being used, since the URL matches this blacklist pattern: ${a}`),!1;return this._whitelist.some(a=>a.test(t))?(n.logger.debug("The navigation route is being used."),!0):(n.logger.log("The navigation route is not being used, since the URL being navigated to doesn't match the whitelist."),!1)}}class b extends g{constructor(e,r,t){c.assert.isInstance(e,RegExp,{moduleName:"workbox-routing",className:"RegExpRoute",funcName:"constructor",paramName:"pattern"});const a=({url:s})=>{const i=e.exec(s.href);return i?s.origin!==location.origin&&i.index!==0?(n.logger.debug(`The regular expression '${e}' only partially matched against the cross-origin URL '${s}'. RegExpRoute's will only handle cross-origin requests if they match the entire URL.`),null):i.slice(1):null};super(a,r,t)}}class k{constructor(){this._routes=new Map}get routes(){return this._routes}addFetchListener(){self.addEventListener("fetch",e=>{const{request:r}=e,t=this.handleRequest({request:r,event:e});t&&e.respondWith(t)})}addCacheListener(){self.addEventListener("message",async e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:r}=e.data;n.logger.debug("Caching URLs from the window",r.urlsToCache);const t=Promise.all(r.urlsToCache.map(a=>{typeof a=="string"&&(a=[a]);const s=new Request(...a);return this.handleRequest({request:s})}));e.waitUntil(t),e.ports&&e.ports[0]&&(await t,e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:r}){c.assert.isInstance(e,Request,{moduleName:"workbox-routing",className:"Router",funcName:"handleRequest",paramName:"options.request"});const t=new URL(e.url,location);if(!t.protocol.startsWith("http")){n.logger.debug("Workbox Router only supports URLs that start with 'http'.");return}let{params:a,route:s}=this.findMatchingRoute({url:t,request:e,event:r}),i=s&&s.handler,u=[];if(i&&(u.push(["Found a route to handle this request:",s]),a&&u.push(["Passing the following params to the route's handler:",a])),!i&&this._defaultHandler&&(u.push("Failed to find a matching route. Falling back to the default handler."),s="[Default Handler]",i=this._defaultHandler),!i){n.logger.debug(`No route found for: ${R.getFriendlyURL(t)}`);return}n.logger.groupCollapsed(`Router is responding to: ${R.getFriendlyURL(t)}`),u.forEach(d=>{Array.isArray(d)?n.logger.log(...d):n.logger.log(d)}),n.logger.groupCollapsed("View request details here."),n.logger.log(e),n.logger.groupEnd(),n.logger.groupEnd();let h;try{h=i.handle({url:t,request:e,event:r,params:a})}catch(d){h=Promise.reject(d)}return h&&this._catchHandler&&(h=h.catch(d=>(n.logger.groupCollapsed(`Error thrown when responding to:  ${R.getFriendlyURL(t)}. Falling back to Catch Handler.`),n.logger.error("Error thrown by:",s),n.logger.error(d),n.logger.groupEnd(),this._catchHandler.handle({url:t,event:r,err:d})))),h}findMatchingRoute({url:e,request:r,event:t}){c.assert.isInstance(e,URL,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.url"}),c.assert.isInstance(r,Request,{moduleName:"workbox-routing",className:"Router",funcName:"findMatchingRoute",paramName:"options.request"});const a=this._routes.get(r.method)||[];for(const s of a){let i,u=s.match({url:e,request:r,event:t});if(u)return(Array.isArray(u)&&u.length>0||u.constructor===Object&&Object.keys(u).length>0)&&(i=u),{route:s,params:i}}return{}}setDefaultHandler(e){this._defaultHandler=N(e)}setCatchHandler(e){this._catchHandler=N(e)}registerRoute(e){c.assert.isType(e,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.assert.hasMethod(e,"match",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.assert.isType(e.handler,"object",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route"}),c.assert.hasMethod(e.handler,"handle",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.handler"}),c.assert.isType(e.method,"string",{moduleName:"workbox-routing",className:"Router",funcName:"registerRoute",paramName:"route.method"}),this._routes.has(e.method)||this._routes.set(e.method,[]),this._routes.get(e.method).push(e)}unregisterRoute(e){if(!this._routes.has(e.method))throw new m.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const r=this._routes.get(e.method).indexOf(e);if(r>-1)this._routes.get(e.method).splice(r,1);else throw new m.WorkboxError("unregister-route-route-not-registered")}}let f;const p=()=>(f||(f=new k,f.addFetchListener(),f.addCacheListener()),f),T=(o,e={})=>{c.assert.isType(o,"string",{moduleName:"workbox-routing",funcName:"registerNavigationRoute",paramName:"cachedAssetUrl"});const r=x.cacheNames.getPrecacheName(e.cacheName),t=async()=>{try{const i=await caches.match(o,{cacheName:r});if(i)return i;throw new Error(`The cache ${r} did not have an entry for ${o}.`)}catch(i){return n.logger.debug("Unable to respond to navigation request with cached response. Falling back to network.",i),fetch(o)}},a=new w(t,{whitelist:e.whitelist,blacklist:e.blacklist});return p().registerRoute(a),a},C=(o,e,r="GET")=>{let t;if(typeof o=="string"){const s=new URL(o,location);{if(!(o.startsWith("/")||o.startsWith("http")))throw new m.WorkboxError("invalid-string",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});const u=o.startsWith("http")?s.pathname:o,h="[*:?+]";u.match(new RegExp(`${h}`))&&n.logger.debug(`The '$capture' parameter contains an Express-style wildcard character (${h}). Strings are now always interpreted as exact matches; use a RegExp for partial or wildcard matches.`)}const i=({url:u})=>(u.pathname===s.pathname&&u.origin!==s.origin&&n.logger.debug(`${o} only partially matches the cross-origin URL ${u}. This route will only handle cross-origin requests if they match the entire URL.`),u.href===s.href);t=new g(i,e,r)}else if(o instanceof RegExp)t=new b(o,e,r);else if(typeof o=="function")t=new g(o,e,r);else if(o instanceof g)t=o;else throw new m.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});return p().registerRoute(t),t},H=o=>{p().setCatchHandler(o)},L=o=>{p().setDefaultHandler(o)};return c.assert.isSWEnv("workbox-routing"),l.NavigationRoute=w,l.RegExpRoute=b,l.registerNavigationRoute=T,l.registerRoute=C,l.Route=g,l.Router=k,l.setCatchHandler=H,l.setDefaultHandler=L,l}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
