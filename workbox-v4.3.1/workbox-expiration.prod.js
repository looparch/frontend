this.workbox=this.workbox||{},this.workbox.expiration=function(c,x,g,f,k,b){"use strict";try{self["workbox:expiration:4.3.1"]&&_()}catch{}const y="workbox-expiration",r="cache-entries",u=t=>{const e=new URL(t,location);return e.hash="",e.href};class E{constructor(e){this.t=e,this.s=new x.DBWrapper(y,1,{onupgradeneeded:s=>this.i(s)})}i(e){const s=e.target.result.createObjectStore(r,{keyPath:"id"});s.createIndex("cacheName","cacheName",{unique:!1}),s.createIndex("timestamp","timestamp",{unique:!1}),g.deleteDatabase(this.t)}async setTimestamp(e,s){e=u(e),await this.s.put(r,{url:e,timestamp:s,cacheName:this.t,id:this.h(e)})}async getTimestamp(e){return(await this.s.get(r,this.h(e))).timestamp}async expireEntries(e,s){const i=await this.s.transaction(r,"readwrite",(a,h)=>{const l=a.objectStore(r),m=[];let d=0;l.index("timestamp").openCursor(null,"prev").onsuccess=({target:N})=>{const o=N.result;if(o){const w=o.value;w.cacheName===this.t&&(e&&w.timestamp<e||s&&d>=s?m.push(o.value):d++),o.continue()}else h(m)}}),n=[];for(const a of i)await this.s.delete(r,a.id),n.push(a.url);return n}h(e){return this.t+"|"+u(e)}}class p{constructor(e,s={}){this.o=!1,this.u=!1,this.l=s.maxEntries,this.p=s.maxAgeSeconds,this.t=e,this.m=new E(e)}async expireEntries(){if(this.o)return void(this.u=!0);this.o=!0;const e=this.p?Date.now()-1e3*this.p:void 0,s=await this.m.expireEntries(e,this.l),i=await caches.open(this.t);for(const n of s)await i.delete(n);this.o=!1,this.u&&(this.u=!1,this.expireEntries())}async updateTimestamp(e){await this.m.setTimestamp(e,Date.now())}async isURLExpired(e){return await this.m.getTimestamp(e)<Date.now()-1e3*this.p}async delete(){this.u=!1,await this.m.expireEntries(1/0)}}return c.CacheExpiration=p,c.Plugin=class{constructor(t={}){this.D=t,this.p=t.maxAgeSeconds,this.g=new Map,t.purgeOnQuotaError&&b.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}k(t){if(t===k.cacheNames.getRuntimeName())throw new f.WorkboxError("expire-custom-caches-only");let e=this.g.get(t);return e||(e=new p(t,this.D),this.g.set(t,e)),e}cachedResponseWillBeUsed({event:t,request:e,cacheName:s,cachedResponse:i}){if(!i)return null;let n=this.N(i);const a=this.k(s);a.expireEntries();const h=a.updateTimestamp(e.url);if(t)try{t.waitUntil(h)}catch{}return n?i:null}N(t){if(!this.p)return!0;const e=this._(t);return e===null||e>=Date.now()-1e3*this.p}_(t){if(!t.headers.has("date"))return null;const e=t.headers.get("date"),s=new Date(e).getTime();return isNaN(s)?null:s}async cacheDidUpdate({cacheName:t,request:e}){const s=this.k(t);await s.updateTimestamp(e.url),await s.expireEntries()}async deleteCacheAndMetadata(){for(const[t,e]of this.g)await caches.delete(t),await e.delete();this.g=new Map}},c}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);
