this.workbox=this.workbox||{},this.workbox.backgroundSync=function(h,d,f){"use strict";try{self["workbox:background-sync:4.3.1"]&&_()}catch{}const y=3,g="workbox-background-sync",n="requests",o="queueName";class q{constructor(t){this.t=t,this.s=new f.DBWrapper(g,y,{onupgradeneeded:this.i})}async pushEntry(t){delete t.id,t.queueName=this.t,await this.s.add(n,t)}async unshiftEntry(t){const[e]=await this.s.getAllMatching(n,{count:1});e?t.id=e.id-1:delete t.id,t.queueName=this.t,await this.s.add(n,t)}async popEntry(){return this.h({direction:"prev"})}async shiftEntry(){return this.h({direction:"next"})}async getAll(){return await this.s.getAllMatching(n,{index:o,query:IDBKeyRange.only(this.t)})}async deleteEntry(t){await this.s.delete(n,t)}async h({direction:t}){const[e]=await this.s.getAllMatching(n,{direction:t,index:o,query:IDBKeyRange.only(this.t),count:1});if(e)return await this.deleteEntry(e.id),e}i(t){const e=t.target.result;t.oldVersion>0&&t.oldVersion<y&&e.objectStoreNames.contains(n)&&e.deleteObjectStore(n),e.createObjectStore(n,{autoIncrement:!0,keyPath:"id"}).createIndex(o,o,{unique:!1})}}const p=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class r{static async fromRequest(t){const e={url:t.url,headers:{}};t.method!=="GET"&&(e.body=await t.clone().arrayBuffer());for(const[s,a]of t.headers.entries())e.headers[s]=a;for(const s of p)t[s]!==void 0&&(e[s]=t[s]);return new r(e)}constructor(t){t.mode==="navigate"&&(t.mode="same-origin"),this.o=t}toObject(){const t=Object.assign({},this.o);return t.headers=Object.assign({},this.o.headers),t.body&&(t.body=t.body.slice(0)),t}toRequest(){return new Request(this.o.url,this.o)}clone(){return new r(this.toObject())}}const l="workbox-background-sync",b=10080,u=new Set;class w{constructor(t,{onSync:e,maxRetentionTime:s}={}){if(u.has(t))throw new d.WorkboxError("duplicate-queue-name",{name:t});u.add(t),this.u=t,this.l=e||this.replayRequests,this.q=s||b,this.m=new q(this.u),this.p()}get name(){return this.u}async pushRequest(t){await this.g(t,"push")}async unshiftRequest(t){await this.g(t,"unshift")}async popRequest(){return this.R("pop")}async shiftRequest(){return this.R("shift")}async getAll(){const t=await this.m.getAll(),e=Date.now(),s=[];for(const a of t){const c=60*this.q*1e3;e-a.timestamp>c?await this.m.deleteEntry(a.id):s.push(m(a))}return s}async g({request:t,metadata:e,timestamp:s=Date.now()},a){const c={requestData:(await r.fromRequest(t.clone())).toObject(),timestamp:s};e&&(c.metadata=e),await this.m[`${a}Entry`](c),this.k?this.D=!0:await this.registerSync()}async R(t){const e=Date.now(),s=await this.m[`${t}Entry`]();if(s){const a=60*this.q*1e3;return e-s.timestamp>a?this.R(t):m(s)}}async replayRequests(){let t;for(;t=await this.shiftRequest();)try{await fetch(t.request.clone())}catch{throw await this.unshiftRequest(t),new d.WorkboxError("queue-replay-failed",{name:this.u})}}async registerSync(){if("sync"in registration)try{await registration.sync.register(`${l}:${this.u}`)}catch{}}p(){"sync"in registration?self.addEventListener("sync",t=>{if(t.tag===`${l}:${this.u}`){const e=async()=>{let s;this.k=!0;try{await this.l({queue:this})}catch(a){throw s=a}finally{!this.D||s&&!t.lastChance||await this.registerSync(),this.k=!1,this.D=!1}};t.waitUntil(e())}}):this.l({queue:this})}static get _(){return u}}const m=i=>{const t={request:new r(i.requestData).toRequest(),timestamp:i.timestamp};return i.metadata&&(t.metadata=i.metadata),t};return h.Queue=w,h.Plugin=class{constructor(...i){this.v=new w(...i),this.fetchDidFail=this.fetchDidFail.bind(this)}async fetchDidFail({request:i}){await this.v.pushRequest({request:i})}},h}({},workbox.core._private,workbox.core._private);
