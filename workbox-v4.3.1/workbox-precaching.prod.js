this.workbox=this.workbox||{},this.workbox.precaching=function(u,w,k,P,f){"use strict";try{self["workbox:precaching:4.3.1"]&&_()}catch{}const m=[],g={get:()=>m,add(e){m.push(...e)}},E="__WB_REVISION__";function W(e){if(!e)throw new f.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(typeof e=="string"){const a=new URL(e,location);return{cacheKey:a.href,url:a.href}}const{revision:t,url:s}=e;if(!s)throw new f.WorkboxError("add-to-cache-list-unexpected-type",{entry:e});if(!t){const a=new URL(s,location);return{cacheKey:a.href,url:a.href}}const r=new URL(s,location),n=new URL(s,location);return n.searchParams.set(E,t),{cacheKey:n.href,url:r.href}}class U{constructor(t){this.t=w.cacheNames.getPrecacheName(t),this.s=new Map}addToCacheList(t){for(const s of t){const{cacheKey:r,url:n}=W(s);if(this.s.has(n)&&this.s.get(n)!==r)throw new f.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this.s.get(n),secondEntry:r});this.s.set(n,r)}}async install({event:t,plugins:s}={}){const r=[],n=[],a=await caches.open(this.t),o=await a.keys(),i=new Set(o.map(c=>c.url));for(const c of this.s.values())i.has(c)?n.push(c):r.push(c);const h=r.map(c=>this.o({event:t,plugins:s,url:c}));return await Promise.all(h),{updatedURLs:r,notUpdatedURLs:n}}async activate(){const t=await caches.open(this.t),s=await t.keys(),r=new Set(this.s.values()),n=[];for(const a of s)r.has(a.url)||(await t.delete(a),n.push(a.url));return{deletedURLs:n}}async o({url:t,event:s,plugins:r}){const n=new Request(t,{credentials:"same-origin"});let a,o=await P.fetchWrapper.fetch({event:s,plugins:r,request:n});for(const i of r||[])"cacheWillUpdate"in i&&(a=i.cacheWillUpdate.bind(i));if(!(a?a({event:s,request:n,response:o}):o.status<400))throw new f.WorkboxError("bad-precaching-response",{url:t,status:o.status});o.redirected&&(o=await async function(i){const h=i.clone(),c="body"in h?Promise.resolve(h.body):h.blob(),d=await c;return new Response(d,{headers:h.headers,status:h.status,statusText:h.statusText})}(o)),await k.cacheWrapper.put({event:s,plugins:r,request:n,response:o,cacheName:this.t,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this.s}getCachedURLs(){return[...this.s.keys()]}getCacheKeyForURL(t){const s=new URL(t,location);return this.s.get(s.href)}}let y;const p=()=>(y||(y=new U),y),C=(e,t)=>{const s=p().getURLsToCacheKeys();for(const r of function*(n,{ignoreURLParametersMatching:a,directoryIndex:o,cleanURLs:i,urlManipulation:h}={}){const c=new URL(n,location);c.hash="",yield c.href;const d=function(l,L){for(const b of[...l.searchParams.keys()])L.some(M=>M.test(b))&&l.searchParams.delete(b);return l}(c,a);if(yield d.href,o&&d.pathname.endsWith("/")){const l=new URL(d);l.pathname+=o,yield l.href}if(i){const l=new URL(d);l.pathname+=".html",yield l.href}if(h){const l=h({url:c});for(const L of l)yield L.href}}(e,t)){const n=s.get(r);if(n)return n}};let R=!1;const v=e=>{R||((({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:s="index.html",cleanURLs:r=!0,urlManipulation:n=null}={})=>{const a=w.cacheNames.getPrecacheName();addEventListener("fetch",o=>{const i=C(o.request.url,{cleanURLs:r,directoryIndex:s,ignoreURLParametersMatching:t,urlManipulation:n});if(!i)return;let h=caches.open(a).then(c=>c.match(i)).then(c=>c||fetch(i));o.respondWith(h)})})(e),R=!0)},K=e=>{const t=p(),s=g.get();e.waitUntil(t.install({event:e,plugins:s}).catch(r=>{throw r}))},N=e=>{const t=p(),s=g.get();e.waitUntil(t.activate({event:e,plugins:s}))},x=e=>{p().addToCacheList(e),e.length>0&&(addEventListener("install",K),addEventListener("activate",N))};return u.addPlugins=e=>{g.add(e)},u.addRoute=v,u.cleanupOutdatedCaches=()=>{addEventListener("activate",e=>{const t=w.cacheNames.getPrecacheName();e.waitUntil((async(s,r="-precache-")=>{const n=(await caches.keys()).filter(a=>a.includes(r)&&a.includes(self.registration.scope)&&a!==s);return await Promise.all(n.map(a=>caches.delete(a))),n})(t).then(s=>{}))})},u.getCacheKeyForURL=e=>p().getCacheKeyForURL(e),u.precache=x,u.precacheAndRoute=(e,t)=>{x(e),v(t)},u.PrecacheController=U,u}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
