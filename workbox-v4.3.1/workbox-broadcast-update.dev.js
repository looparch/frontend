this.workbox=this.workbox||{},this.workbox.broadcastUpdate=function(d,n,p,i,w,f){"use strict";try{self["workbox:broadcast-update:4.3.1"]&&_()}catch{}const c=(o,e,a)=>{if(!(o instanceof Response&&e instanceof Response))throw new f.WorkboxError("invalid-responses-are-same-args");return a.some(t=>o.headers.has(t)&&e.headers.has(t))?a.every(t=>{const r=o.headers.has(t)===e.headers.has(t),m=o.headers.get(t)===e.headers.get(t);return r&&m}):(i.logger.warn("Unable to determine where the response has been updated because none of the headers that would be checked are present."),i.logger.debug("Attempting to compare the following: ",o,e,a),!0)},b="CACHE_UPDATED",g="workbox-broadcast-update",N="workbox",E=1e4,U=["content-length","etag","last-modified"],h=async({channel:o,cacheName:e,url:a})=>{n.assert.isType(e,"string",{moduleName:"workbox-broadcast-update",className:"~",funcName:"broadcastUpdate",paramName:"cacheName"}),n.assert.isType(a,"string",{moduleName:"workbox-broadcast-update",className:"~",funcName:"broadcastUpdate",paramName:"url"});const s={type:b,meta:g,payload:{cacheName:e,updatedURL:a}};if(o)o.postMessage(s);else{const t=await clients.matchAll({type:"window"});for(const r of t)r.postMessage(s)}};class u{constructor({headersToCheck:e,channelName:a,deferNoticationTimeout:s}={}){this._headersToCheck=e||U,this._channelName=a||N,this._deferNoticationTimeout=s||E,n.assert.isType(this._channelName,"string",{moduleName:"workbox-broadcast-update",className:"BroadcastCacheUpdate",funcName:"constructor",paramName:"channelName"}),n.assert.isArray(this._headersToCheck,{moduleName:"workbox-broadcast-update",className:"BroadcastCacheUpdate",funcName:"constructor",paramName:"headersToCheck"}),this._initWindowReadyDeferreds()}notifyIfUpdated({oldResponse:e,newResponse:a,url:s,cacheName:t,event:r}){if(!c(e,a,this._headersToCheck)){i.logger.log("Newer response found (and cached) for:",s);const l=(async()=>{r&&r.request&&r.request.mode==="navigate"&&(i.logger.debug("Original request was a navigation request, waiting for a ready message from the window",r.request),await this._windowReadyOrTimeout(r)),await this._broadcastUpdate({channel:this._getChannel(),cacheName:t,url:s})})();if(r)try{r.waitUntil(l)}catch{i.logger.warn(`Unable to ensure service worker stays alive when broadcasting cache update for ${p.getFriendlyURL(r.request.url)}'.`)}return l}}async _broadcastUpdate(e){await h(e)}_getChannel(){return"BroadcastChannel"in self&&!this._channel&&(this._channel=new BroadcastChannel(this._channelName)),this._channel}_windowReadyOrTimeout(e){if(!this._navigationEventsDeferreds.has(e)){const a=new w.Deferred;this._navigationEventsDeferreds.set(e,a);const s=setTimeout(()=>{i.logger.debug(`Timed out after ${this._deferNoticationTimeout}ms waiting for message from window`),a.resolve()},this._deferNoticationTimeout);a.promise.then(()=>clearTimeout(s))}return this._navigationEventsDeferreds.get(e).promise}_initWindowReadyDeferreds(){this._navigationEventsDeferreds=new Map,self.addEventListener("message",e=>{if(e.data.type==="WINDOW_READY"&&e.data.meta==="workbox-window"&&this._navigationEventsDeferreds.size>0){i.logger.debug("Received WINDOW_READY event: ",e);for(const a of this._navigationEventsDeferreds.values())a.resolve();this._navigationEventsDeferreds.clear()}})}}class D{constructor(e){this._broadcastUpdate=new u(e)}cacheDidUpdate({cacheName:e,oldResponse:a,newResponse:s,request:t,event:r}){n.assert.isType(e,"string",{moduleName:"workbox-broadcast-update",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),n.assert.isInstance(s,Response,{moduleName:"workbox-broadcast-update",className:"Plugin",funcName:"cacheDidUpdate",paramName:"newResponse"}),n.assert.isInstance(t,Request,{moduleName:"workbox-broadcast-update",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"}),a&&this._broadcastUpdate.notifyIfUpdated({cacheName:e,oldResponse:a,newResponse:s,event:r,url:t.url})}}return d.BroadcastCacheUpdate=u,d.Plugin=D,d.broadcastUpdate=h,d.responsesAreSame=c,d}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
