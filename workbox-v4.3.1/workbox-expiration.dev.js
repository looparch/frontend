this.workbox=this.workbox||{},this.workbox.expiration=function(d,E,f,m,i,s,b,y,k){"use strict";try{self["workbox:expiration:4.3.1"]&&_()}catch{}const T="workbox-expiration",n="cache-entries",x=c=>{const e=new URL(c,location);return e.hash="",e.href};class A{constructor(e){this._cacheName=e,this._db=new E.DBWrapper(T,1,{onupgradeneeded:t=>this._handleUpgrade(t)})}_handleUpgrade(e){const a=e.target.result.createObjectStore(n,{keyPath:"id"});a.createIndex("cacheName","cacheName",{unique:!1}),a.createIndex("timestamp","timestamp",{unique:!1}),f.deleteDatabase(this._cacheName)}async setTimestamp(e,t){e=x(e),await this._db.put(n,{url:e,timestamp:t,cacheName:this._cacheName,id:this._getId(e)})}async getTimestamp(e){return(await this._db.get(n,this._getId(e))).timestamp}async expireEntries(e,t){const a=await this._db.transaction(n,"readwrite",(o,h)=>{const p=o.objectStore(n),l=[];let g=0;p.index("timestamp").openCursor(null,"prev").onsuccess=({target:D})=>{const u=D.result;if(u){const N=u.value;N.cacheName===this._cacheName&&(e&&N.timestamp<e||t&&g>=t?l.push(u.value):g++),u.continue()}else h(l)}}),r=[];for(const o of a)await this._db.delete(n,o.id),r.push(o.url);return r}_getId(e){return this._cacheName+"|"+x(e)}}class w{constructor(e,t={}){{if(i.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"cacheName"}),!(t.maxEntries||t.maxAgeSeconds))throw new m.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor"});t.maxEntries&&i.assert.isType(t.maxEntries,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxEntries"}),t.maxAgeSeconds&&i.assert.isType(t.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._isRunning=!1,this._rerunRequested=!1,this._maxEntries=t.maxEntries,this._maxAgeSeconds=t.maxAgeSeconds,this._cacheName=e,this._timestampModel=new A(e)}async expireEntries(){if(this._isRunning){this._rerunRequested=!0;return}this._isRunning=!0;const e=this._maxAgeSeconds?Date.now()-this._maxAgeSeconds*1e3:void 0,t=await this._timestampModel.expireEntries(e,this._maxEntries),a=await caches.open(this._cacheName);for(const r of t)await a.delete(r);t.length>0?(s.logger.groupCollapsed(`Expired ${t.length} ${t.length===1?"entry":"entries"} and removed ${t.length===1?"it":"them"} from the '${this._cacheName}' cache.`),s.logger.log(`Expired the following ${t.length===1?"URL":"URLs"}:`),t.forEach(r=>s.logger.log(`    ${r}`)),s.logger.groupEnd()):s.logger.debug("Cache expiration ran and found no entries to remove."),this._isRunning=!1,this._rerunRequested&&(this._rerunRequested=!1,this.expireEntries())}async updateTimestamp(e){i.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"CacheExpiration",funcName:"updateTimestamp",paramName:"url"}),await this._timestampModel.setTimestamp(e,Date.now())}async isURLExpired(e){if(!this._maxAgeSeconds)throw new m.WorkboxError("expired-test-without-max-age",{methodName:"isURLExpired",paramName:"maxAgeSeconds"});const t=await this._timestampModel.getTimestamp(e),a=Date.now()-this._maxAgeSeconds*1e3;return t<a}async delete(){this._rerunRequested=!1,await this._timestampModel.expireEntries(1/0)}}class S{constructor(e={}){{if(!(e.maxEntries||e.maxAgeSeconds))throw new m.WorkboxError("max-entries-or-age-required",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor"});e.maxEntries&&i.assert.isType(e.maxEntries,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxEntries"}),e.maxAgeSeconds&&i.assert.isType(e.maxAgeSeconds,"number",{moduleName:"workbox-expiration",className:"Plugin",funcName:"constructor",paramName:"config.maxAgeSeconds"})}this._config=e,this._maxAgeSeconds=e.maxAgeSeconds,this._cacheExpirations=new Map,e.purgeOnQuotaError&&k.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}_getCacheExpiration(e){if(e===b.cacheNames.getRuntimeName())throw new m.WorkboxError("expire-custom-caches-only");let t=this._cacheExpirations.get(e);return t||(t=new w(e,this._config),this._cacheExpirations.set(e,t)),t}cachedResponseWillBeUsed({event:e,request:t,cacheName:a,cachedResponse:r}){if(!r)return null;let o=this._isResponseDateFresh(r);const h=this._getCacheExpiration(a);h.expireEntries();const p=h.updateTimestamp(t.url);if(e)try{e.waitUntil(p)}catch{s.logger.warn(`Unable to ensure service worker stays alive when updating cache entry for '${y.getFriendlyURL(e.request.url)}'.`)}return o?r:null}_isResponseDateFresh(e){if(!this._maxAgeSeconds)return!0;const t=this._getDateHeaderTimestamp(e);if(t===null)return!0;const a=Date.now();return t>=a-this._maxAgeSeconds*1e3}_getDateHeaderTimestamp(e){if(!e.headers.has("date"))return null;const t=e.headers.get("date"),r=new Date(t).getTime();return isNaN(r)?null:r}async cacheDidUpdate({cacheName:e,request:t}){i.assert.isType(e,"string",{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"cacheName"}),i.assert.isInstance(t,Request,{moduleName:"workbox-expiration",className:"Plugin",funcName:"cacheDidUpdate",paramName:"request"});const a=this._getCacheExpiration(e);await a.updateTimestamp(t.url),await a.expireEntries()}async deleteCacheAndMetadata(){for(const[e,t]of this._cacheExpirations)await caches.delete(e),await t.delete();this._cacheExpirations=new Map}}return d.CacheExpiration=w,d.Plugin=S,d}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);
