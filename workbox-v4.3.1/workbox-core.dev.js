this.workbox=this.workbox||{},this.workbox.core=function(w){"use strict";try{self["workbox:core:4.3.1"]&&_()}catch{}const l=(()=>{let e=!1;const t={debug:"#7f8c8d",log:"#2ecc71",warn:"#f39c12",error:"#c0392b",groupCollapsed:"#3498db",groupEnd:null},r=function(n,a){if(n==="groupCollapsed"&&/^((?!chrome|android).)*safari/i.test(navigator.userAgent)){console[n](...a);return}const i=[`background: ${t[n]}`,"border-radius: 0.5em","color: white","font-weight: bold","padding: 2px 0.5em"],s=e?[]:["%cworkbox",i.join(";")];console[n](...s,...a),n==="groupCollapsed"&&(e=!0),n==="groupEnd"&&(e=!1)},o={};for(const n of Object.keys(t))o[n]=(...a)=>{r(n,a)};return o})(),U={"invalid-value":({paramName:e,validValueDescription:t,value:r})=>{if(!e||!t)throw new Error("Unexpected input to 'invalid-value' error.");return`The '${e}' parameter was given a value with an unexpected value. ${t} Received a value of ${JSON.stringify(r)}.`},"not-in-sw":({moduleName:e})=>{if(!e)throw new Error("Unexpected input to 'not-in-sw' error.");return`The '${e}' must be used in a service worker.`},"not-an-array":({moduleName:e,className:t,funcName:r,paramName:o})=>{if(!e||!t||!r||!o)throw new Error("Unexpected input to 'not-an-array' error.");return`The parameter '${o}' passed into '${e}.${t}.${r}()' must be an array.`},"incorrect-type":({expectedType:e,paramName:t,moduleName:r,className:o,funcName:n})=>{if(!e||!t||!r||!n)throw new Error("Unexpected input to 'incorrect-type' error.");return`The parameter '${t}' passed into '${r}.${o?o+".":""}${n}()' must be of type ${e}.`},"incorrect-class":({expectedClass:e,paramName:t,moduleName:r,className:o,funcName:n,isReturnValueProblem:a})=>{if(!e||!r||!n)throw new Error("Unexpected input to 'incorrect-class' error.");return a?`The return value from '${r}.${o?o+".":""}${n}()' must be an instance of class ${e.name}.`:`The parameter '${t}' passed into '${r}.${o?o+".":""}${n}()' must be an instance of class ${e.name}.`},"missing-a-method":({expectedMethod:e,paramName:t,moduleName:r,className:o,funcName:n})=>{if(!e||!t||!r||!o||!n)throw new Error("Unexpected input to 'missing-a-method' error.");return`${r}.${o}.${n}() expected the '${t}' parameter to expose a '${e}' method.`},"add-to-cache-list-unexpected-type":({entry:e})=>`An unexpected entry was passed to 'workbox-precaching.PrecacheController.addToCacheList()' The entry '${JSON.stringify(e)}' isn't supported. You must supply an array of strings with one or more characters, objects with a url property or Request objects.`,"add-to-cache-list-conflicting-entries":({firstEntry:e,secondEntry:t})=>{if(!e||!t)throw new Error("Unexpected input to 'add-to-cache-list-duplicate-entries' error.");return`Two of the entries passed to 'workbox-precaching.PrecacheController.addToCacheList()' had the URL ${e._entryId} but different revision details. Workbox is is unable to cache and version the asset correctly. Please remove one of the entries.`},"plugin-error-request-will-fetch":({thrownError:e})=>{if(!e)throw new Error("Unexpected input to 'plugin-error-request-will-fetch', error.");return`An error was thrown by a plugins 'requestWillFetch()' method. The thrown error message was: '${e.message}'.`},"invalid-cache-name":({cacheNameId:e,value:t})=>{if(!e)throw new Error("Expected a 'cacheNameId' for error 'invalid-cache-name'");return`You must provide a name containing at least one character for setCacheDeatils({${e}: '...'}). Received a value of '${JSON.stringify(t)}'`},"unregister-route-but-not-found-with-method":({method:e})=>{if(!e)throw new Error("Unexpected input to 'unregister-route-but-not-found-with-method' error.");return`The route you're trying to unregister was not  previously registered for the method type '${e}'.`},"unregister-route-route-not-registered":()=>"The route you're trying to unregister was not previously registered.","queue-replay-failed":({name:e})=>`Replaying the background sync queue '${e}' failed.`,"duplicate-queue-name":({name:e})=>`The Queue name '${e}' is already being used. All instances of backgroundSync.Queue must be given unique names.`,"expired-test-without-max-age":({methodName:e,paramName:t})=>`The '${e}()' method can only be used when the '${t}' is used in the constructor.`,"unsupported-route-type":({moduleName:e,className:t,funcName:r,paramName:o})=>`The supplied '${o}' parameter was an unsupported type. Please check the docs for ${e}.${t}.${r} for valid input types.`,"not-array-of-class":({value:e,expectedClass:t,moduleName:r,className:o,funcName:n,paramName:a})=>`The supplied '${a}' parameter must be an array of '${t}' objects. Received '${JSON.stringify(e)},'. Please check the call to ${r}.${o}.${n}() to fix the issue.`,"max-entries-or-age-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.maxEntries or config.maxAgeSecondsin ${e}.${t}.${r}`,"statuses-or-headers-required":({moduleName:e,className:t,funcName:r})=>`You must define either config.statuses or config.headersin ${e}.${t}.${r}`,"invalid-string":({moduleName:e,className:t,funcName:r,paramName:o})=>{if(!o||!e||!r)throw new Error("Unexpected input to 'invalid-string' error.");return`When using strings, the '${o}' parameter must start with 'http' (for cross-origin matches) or '/' (for same-origin matches). Please see the docs for ${e}.${r}() for more info.`},"channel-name-required":()=>"You must provide a channelName to construct a BroadcastCacheUpdate instance.","invalid-responses-are-same-args":()=>"The arguments passed into responsesAreSame() appear to be invalid. Please ensure valid Responses are used.","expire-custom-caches-only":()=>"You must provide a 'cacheName' property when using the expiration plugin with a runtime caching strategy.","unit-must-be-bytes":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'unit-must-be-bytes' error.");return`The 'unit' portion of the Range header must be set to 'bytes'. The Range header provided was "${e}"`},"single-range-only":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'single-range-only' error.");return`Multiple ranges are not supported. Please use a  single start value, and optional end value. The Range header provided was "${e}"`},"invalid-range-values":({normalizedRangeHeader:e})=>{if(!e)throw new Error("Unexpected input to 'invalid-range-values' error.");return`The Range header is missing both start and end values. At least one of those values is needed. The Range header provided was "${e}"`},"no-range-header":()=>"No Range header was found in the Request provided.","range-not-satisfiable":({size:e,start:t,end:r})=>`The start (${t}) and end (${r}) values in the Range are not satisfiable by the cached response, which is ${e} bytes.`,"attempt-to-cache-non-get-request":({url:e,method:t})=>`Unable to cache '${e}' because it is a '${t}' request and only 'GET' requests can be cached.`,"cache-put-with-no-response":({url:e})=>`There was an attempt to cache '${e}' but the response was not defined.`,"no-response":({url:e,error:t})=>{let r=`The strategy could not generate a response for '${e}'.`;return t&&(r+=` The underlying error is ${t}.`),r},"bad-precaching-response":({url:e,status:t})=>`The precaching request for '${e}' failed with an HTTP status of ${t}.`},P=(e,...t)=>{const r=U[e];if(!r)throw new Error(`Unable to find message for code '${e}'.`);return r(...t)};class h extends Error{constructor(t,r){let o=P(t,r);super(o),this.name=t,this.details=r}}const d={hasMethod:(e,t,{moduleName:r,className:o,funcName:n,paramName:a})=>{if(typeof e[t]!=="function")throw new h("missing-a-method",{paramName:a,expectedMethod:t,moduleName:r,className:o,funcName:n})},isArray:(e,{moduleName:t,className:r,funcName:o,paramName:n})=>{if(!Array.isArray(e))throw new h("not-an-array",{moduleName:t,className:r,funcName:o,paramName:n})},isInstance:(e,t,{moduleName:r,className:o,funcName:n,paramName:a,isReturnValueProblem:i})=>{if(!(e instanceof t))throw new h("incorrect-class",{paramName:a,expectedClass:t,moduleName:r,className:o,funcName:n,isReturnValueProblem:i})},isOneOf:(e,t,{paramName:r})=>{if(!t.includes(e))throw new h("invalid-value",{paramName:r,value:e,validValueDescription:`Valid values are ${JSON.stringify(t)}.`})},isSWEnv:e=>{if(!("ServiceWorkerGlobalScope"in self))throw new h("not-in-sw",{moduleName:e})},isType:(e,t,{moduleName:r,className:o,funcName:n,paramName:a})=>{if(typeof e!==t)throw new h("incorrect-type",{paramName:a,expectedType:t,moduleName:r,className:o,funcName:n})},isArrayOfClass:(e,t,{moduleName:r,className:o,funcName:n,paramName:a})=>{const i=new h("not-array-of-class",{value:e,expectedClass:t,moduleName:r,className:o,funcName:n,paramName:a});if(!Array.isArray(e))throw i;for(let s of e)if(!(s instanceof t))throw i}},y=new Set;function S(e){d.isType(e,"function",{moduleName:"workbox-core",funcName:"register",paramName:"callback"}),y.add(e),l.log("Registered a callback to respond to quota errors.",e)}const f={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:self.registration.scope},b=e=>[f.prefix,e,f.suffix].filter(t=>t.length>0).join("-"),m={updateDetails:e=>{Object.keys(f).forEach(t=>{typeof e[t]<"u"&&(f[t]=e[t])})},getGoogleAnalyticsName:e=>e||b(f.googleAnalytics),getPrecacheName:e=>e||b(f.precache),getPrefix:()=>f.prefix,getRuntimeName:e=>e||b(f.runtime),getSuffix:()=>f.suffix},g=e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href};async function D(){l.log(`About to run ${y.size} callbacks to clean up caches.`);for(const e of y)await e(),l.log(e,"is complete.");l.log("Finished running callbacks.")}const c={CACHE_DID_UPDATE:"cacheDidUpdate",CACHE_KEY_WILL_BE_USED:"cacheKeyWillBeUsed",CACHE_WILL_UPDATE:"cacheWillUpdate",CACHED_RESPONSE_WILL_BE_USED:"cachedResponseWillBeUsed",FETCH_DID_FAIL:"fetchDidFail",FETCH_DID_SUCCEED:"fetchDidSucceed",REQUEST_WILL_FETCH:"requestWillFetch"},$={filter:(e,t)=>e.filter(r=>t in r)},I=async({cacheName:e,request:t,response:r,event:o,plugins:n=[],matchOptions:a}={})=>{if(t.method&&t.method!=="GET")throw new h("attempt-to-cache-non-get-request",{url:g(t.url),method:t.method});const i=await R({plugins:n,request:t,mode:"write"});if(!r)throw l.error(`Cannot cache non-existent response for '${g(i.url)}'.`),new h("cache-put-with-no-response",{url:g(i.url)});let s=await L({event:o,plugins:n,response:r,request:i});if(!s){l.debug(`Response '${g(i.url)}' will not be cached.`,s);return}const u=await caches.open(e),E=$.filter(n,c.CACHE_DID_UPDATE);let v=E.length>0?await A({cacheName:e,matchOptions:a,request:i}):null;l.debug(`Updating the '${e}' cache with a new Response for ${g(i.url)}.`);try{await u.put(i,s)}catch(p){throw p.name==="QuotaExceededError"&&await D(),p}for(let p of E)await p[c.CACHE_DID_UPDATE].call(p,{cacheName:e,event:o,oldResponse:v,newResponse:s,request:i})},A=async({cacheName:e,request:t,event:r,matchOptions:o,plugins:n=[]})=>{const a=await caches.open(e),i=await R({plugins:n,request:t,mode:"read"});let s=await a.match(i,o);s?l.debug(`Found a cached response in '${e}'.`):l.debug(`No cached response found in '${e}'.`);for(const u of n)c.CACHED_RESPONSE_WILL_BE_USED in u&&(s=await u[c.CACHED_RESPONSE_WILL_BE_USED].call(u,{cacheName:e,event:r,matchOptions:o,cachedResponse:s,request:i}),s&&d.isInstance(s,Response,{moduleName:"Plugin",funcName:c.CACHED_RESPONSE_WILL_BE_USED,isReturnValueProblem:!0}));return s},L=async({request:e,response:t,event:r,plugins:o})=>{let n=t,a=!1;for(let i of o)if(c.CACHE_WILL_UPDATE in i&&(a=!0,n=await i[c.CACHE_WILL_UPDATE].call(i,{request:e,response:n,event:r}),n&&d.isInstance(n,Response,{moduleName:"Plugin",funcName:c.CACHE_WILL_UPDATE,isReturnValueProblem:!0}),!n))break;return a||(!n.status===200&&(n.status===0?l.warn(`The response for '${e.url}' is an opaque response. The caching strategy that you're using will not cache opaque responses by default.`):l.debug(`The response for '${e.url}' returned a status code of '${t.status}' and won't be cached as a result.`)),n=n.status===200?n:null),n||null},R=async({request:e,mode:t,plugins:r})=>{const o=$.filter(r,c.CACHE_KEY_WILL_BE_USED);let n=e;for(const a of o)n=await a[c.CACHE_KEY_WILL_BE_USED].call(a,{mode:t,request:n}),typeof n=="string"&&(n=new Request(n)),d.isInstance(n,Request,{moduleName:"Plugin",funcName:c.CACHE_KEY_WILL_BE_USED,isReturnValueProblem:!0});return n},W={put:I,match:A};class C{constructor(t,r,{onupgradeneeded:o,onversionchange:n=this._onversionchange}={}){this._name=t,this._version=r,this._onupgradeneeded=o,this._onversionchange=n,this._db=null}get db(){return this._db}async open(){if(!this._db)return this._db=await new Promise((t,r)=>{let o=!1;setTimeout(()=>{o=!0,r(new Error("The open request was blocked and timed out"))},this.OPEN_TIMEOUT);const n=indexedDB.open(this._name,this._version);n.onerror=()=>r(n.error),n.onupgradeneeded=a=>{o?(n.transaction.abort(),a.target.result.close()):this._onupgradeneeded&&this._onupgradeneeded(a)},n.onsuccess=({target:a})=>{const i=a.result;o?i.close():(i.onversionchange=this._onversionchange.bind(this),t(i))}}),this}async getKey(t,r){return(await this.getAllKeys(t,r,1))[0]}async getAll(t,r,o){return await this.getAllMatching(t,{query:r,count:o})}async getAllKeys(t,r,o){return(await this.getAllMatching(t,{query:r,count:o,includeKeys:!0})).map(({key:n})=>n)}async getAllMatching(t,{index:r,query:o=null,direction:n="next",count:a,includeKeys:i}={}){return await this.transaction([t],"readonly",(s,u)=>{const E=s.objectStore(t),v=r?E.index(r):E,p=[];v.openCursor(o,n).onsuccess=({target:j})=>{const T=j.result;if(T){const{primaryKey:K,key:Q,value:x}=T;p.push(i?{primaryKey:K,key:Q,value:x}:x),a&&p.length>=a?u(p):T.continue()}else u(p)}})}async transaction(t,r,o){return await this.open(),await new Promise((n,a)=>{const i=this._db.transaction(t,r);i.onabort=({target:s})=>a(s.error),i.oncomplete=()=>n(),o(i,s=>n(s))})}async _call(t,r,o,...n){const a=(i,s)=>{i.objectStore(r)[t](...n).onsuccess=({target:u})=>{s(u.result)}};return await this.transaction([r],o,a)}_onversionchange(){this.close()}close(){this._db&&(this._db.close(),this._db=null)}}C.prototype.OPEN_TIMEOUT=2e3;const k={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[e,t]of Object.entries(k))for(const r of t)r in IDBObjectStore.prototype&&(C.prototype[r]=async function(o,...n){return await this._call(r,o,e,...n)});class q{constructor(){this.promise=new Promise((t,r)=>{this.resolve=t,this.reject=r})}}var F=Object.freeze({assert:d,cacheNames:m,cacheWrapper:W,DBWrapper:C,Deferred:q,deleteDatabase:async e=>{await new Promise((t,r)=>{const o=indexedDB.deleteDatabase(e);o.onerror=({target:n})=>{r(n.error)},o.onblocked=()=>{r(new Error("Delete blocked"))},o.onsuccess=()=>{t()}})},executeQuotaErrorCallbacks:D,fetchWrapper:{fetch:async({request:e,fetchOptions:t,event:r,plugins:o=[]})=>{if(r&&r.preloadResponse){const s=await r.preloadResponse;if(s)return l.log(`Using a preloaded navigation response for '${g(e.url)}'`),s}typeof e=="string"&&(e=new Request(e)),d.isInstance(e,Request,{paramName:e,expectedClass:"Request",moduleName:"workbox-core",className:"fetchWrapper",funcName:"wrappedFetch"});const n=$.filter(o,c.FETCH_DID_FAIL),a=n.length>0?e.clone():null;try{for(let s of o)c.REQUEST_WILL_FETCH in s&&(e=await s[c.REQUEST_WILL_FETCH].call(s,{request:e.clone(),event:r}),e&&d.isInstance(e,Request,{moduleName:"Plugin",funcName:c.CACHED_RESPONSE_WILL_BE_USED,isReturnValueProblem:!0}))}catch(s){throw new h("plugin-error-request-will-fetch",{thrownError:s})}let i=e.clone();try{let s;e.mode==="navigate"?s=await fetch(e):s=await fetch(e,t),l.debug(`Network request for '${g(e.url)}' returned a response with status '${s.status}'.`);for(const u of o)c.FETCH_DID_SUCCEED in u&&(s=await u[c.FETCH_DID_SUCCEED].call(u,{event:r,request:i,response:s}),s&&d.isInstance(s,Response,{moduleName:"Plugin",funcName:c.FETCH_DID_SUCCEED,isReturnValueProblem:!0}));return s}catch(s){l.error(`Network request for '${g(e.url)}' threw an error.`,s);for(const u of n)await u[c.FETCH_DID_FAIL].call(u,{error:s,event:r,originalRequest:a.clone(),request:i.clone()});throw s}}},getFriendlyURL:g,logger:l,WorkboxError:h});const O=()=>{addEventListener("activate",()=>clients.claim())},N={get googleAnalytics(){return m.getGoogleAnalyticsName()},get precache(){return m.getPrecacheName()},get prefix(){return m.getPrefix()},get runtime(){return m.getRuntimeName()},get suffix(){return m.getSuffix()}},H=e=>{{if(Object.keys(e).forEach(t=>{d.isType(e[t],"string",{moduleName:"workbox-core",funcName:"setCacheNameDetails",paramName:`details.${t}`})}),"precache"in e&&e.precache.length===0)throw new h("invalid-cache-name",{cacheNameId:"precache",value:e.precache});if("runtime"in e&&e.runtime.length===0)throw new h("invalid-cache-name",{cacheNameId:"runtime",value:e.runtime});if("googleAnalytics"in e&&e.googleAnalytics.length===0)throw new h("invalid-cache-name",{cacheNameId:"googleAnalytics",value:e.googleAnalytics})}m.updateDetails(e)},B=()=>{addEventListener("install",()=>self.skipWaiting())};try{self.workbox.v=self.workbox.v||{}}catch{}return w._private=F,w.clientsClaim=O,w.cacheNames=N,w.registerQuotaErrorCallback=S,w.setCacheNameDetails=H,w.skipWaiting=B,w}({});
