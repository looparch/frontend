this.workbox=this.workbox||{},this.workbox.core=function(h){"use strict";try{self["workbox:core:4.3.1"]&&_()}catch{}const j=(e,...t)=>{let r=e;return t.length>0&&(r+=` :: ${JSON.stringify(t)}`),r};class f extends Error{constructor(t,r){super(j(t,r)),this.name=t,this.details=r}}const b=new Set,u={googleAnalytics:"googleAnalytics",precache:"precache-v2",prefix:"workbox",runtime:"runtime",suffix:self.registration.scope},d=e=>[u.prefix,e,u.suffix].filter(t=>t.length>0).join("-"),g={updateDetails:e=>{Object.keys(u).forEach(t=>{e[t]!==void 0&&(u[t]=e[t])})},getGoogleAnalyticsName:e=>e||d(u.googleAnalytics),getPrecacheName:e=>e||d(u.precache),getPrefix:()=>u.prefix,getRuntimeName:e=>e||d(u.runtime),getSuffix:()=>u.suffix},v=e=>{const t=new URL(e,location);return t.origin===location.origin?t.pathname:t.href};async function q(){for(const e of b)await e()}const k="cacheDidUpdate",N="cacheKeyWillBeUsed",E="cacheWillUpdate",D="cachedResponseWillBeUsed",A="fetchDidFail",O="fetchDidSucceed",R="requestWillFetch",w=(e,t)=>e.filter(r=>t in r),K=async({cacheName:e,request:t,event:r,matchOptions:s,plugins:n=[]})=>{const i=await caches.open(e),o=await P({plugins:n,request:t,mode:"read"});let a=await i.match(o,s);for(const c of n)D in c&&(a=await c[D].call(c,{cacheName:e,event:r,matchOptions:s,cachedResponse:a,request:o}));return a},S=async({request:e,response:t,event:r,plugins:s})=>{let n=t,i=!1;for(let o of s)if(E in o&&(i=!0,!(n=await o[E].call(o,{request:e,response:n,event:r}))))break;return i||(n=n.status===200?n:null),n||null},P=async({request:e,mode:t,plugins:r})=>{const s=w(r,N);let n=e;for(const i of s)typeof(n=await i[N].call(i,{mode:t,request:n}))=="string"&&(n=new Request(n));return n},U={put:async({cacheName:e,request:t,response:r,event:s,plugins:n=[],matchOptions:i}={})=>{const o=await P({plugins:n,request:t,mode:"write"});if(!r)throw new f("cache-put-with-no-response",{url:v(o.url)});let a=await S({event:s,plugins:n,response:r,request:o});if(!a)return;const c=await caches.open(e),p=w(n,k);let m=p.length>0?await K({cacheName:e,matchOptions:i,request:o}):null;try{await c.put(o,a)}catch(l){throw l.name==="QuotaExceededError"&&await q(),l}for(let l of p)await l[k].call(l,{cacheName:e,event:s,oldResponse:m,newResponse:a,request:o})},match:K};class y{constructor(t,r,{onupgradeneeded:s,onversionchange:n=this.t}={}){this.s=t,this.i=r,this.o=s,this.t=n,this.l=null}get db(){return this.l}async open(){if(!this.l)return this.l=await new Promise((t,r)=>{let s=!1;setTimeout(()=>{s=!0,r(new Error("The open request was blocked and timed out"))},this.OPEN_TIMEOUT);const n=indexedDB.open(this.s,this.i);n.onerror=()=>r(n.error),n.onupgradeneeded=i=>{s?(n.transaction.abort(),i.target.result.close()):this.o&&this.o(i)},n.onsuccess=({target:i})=>{const o=i.result;s?o.close():(o.onversionchange=this.t.bind(this),t(o))}}),this}async getKey(t,r){return(await this.getAllKeys(t,r,1))[0]}async getAll(t,r,s){return await this.getAllMatching(t,{query:r,count:s})}async getAllKeys(t,r,s){return(await this.getAllMatching(t,{query:r,count:s,includeKeys:!0})).map(({key:n})=>n)}async getAllMatching(t,{index:r,query:s=null,direction:n="next",count:i,includeKeys:o}={}){return await this.transaction([t],"readonly",(a,c)=>{const p=a.objectStore(t),m=r?p.index(r):p,l=[];m.openCursor(s,n).onsuccess=({target:M})=>{const x=M.result;if(x){const{primaryKey:L,key:F,value:W}=x;l.push(o?{primaryKey:L,key:F,value:W}:W),i&&l.length>=i?c(l):x.continue()}else c(l)}})}async transaction(t,r,s){return await this.open(),await new Promise((n,i)=>{const o=this.l.transaction(t,r);o.onabort=({target:a})=>i(a.error),o.oncomplete=()=>n(),s(o,a=>n(a))})}async u(t,r,s,...n){return await this.transaction([r],s,(i,o)=>{i.objectStore(r)[t](...n).onsuccess=({target:a})=>{o(a.result)}})}t(){this.close()}close(){this.l&&(this.l.close(),this.l=null)}}y.prototype.OPEN_TIMEOUT=2e3;const B={readonly:["get","count","getKey","getAll","getAllKeys"],readwrite:["add","put","clear","delete"]};for(const[e,t]of Object.entries(B))for(const r of t)r in IDBObjectStore.prototype&&(y.prototype[r]=async function(s,...n){return await this.u(r,s,e,...n)});var T=Object.freeze({assert:null,cacheNames:g,cacheWrapper:U,DBWrapper:y,Deferred:class{constructor(){this.promise=new Promise((e,t)=>{this.resolve=e,this.reject=t})}},deleteDatabase:async e=>{await new Promise((t,r)=>{const s=indexedDB.deleteDatabase(e);s.onerror=({target:n})=>{r(n.error)},s.onblocked=()=>{r(new Error("Delete blocked"))},s.onsuccess=()=>{t()}})},executeQuotaErrorCallbacks:q,fetchWrapper:{fetch:async({request:e,fetchOptions:t,event:r,plugins:s=[]})=>{if(r&&r.preloadResponse){const a=await r.preloadResponse;if(a)return a}typeof e=="string"&&(e=new Request(e));const n=w(s,A),i=n.length>0?e.clone():null;try{for(let a of s)R in a&&(e=await a[R].call(a,{request:e.clone(),event:r}))}catch(a){throw new f("plugin-error-request-will-fetch",{thrownError:a})}let o=e.clone();try{let a;a=e.mode==="navigate"?await fetch(e):await fetch(e,t);for(const c of s)O in c&&(a=await c[O].call(c,{event:r,request:o,response:a}));return a}catch(a){for(const c of n)await c[A].call(c,{error:a,event:r,originalRequest:i.clone(),request:o.clone()});throw a}}},getFriendlyURL:v,logger:null,WorkboxError:f});const C={get googleAnalytics(){return g.getGoogleAnalyticsName()},get precache(){return g.getPrecacheName()},get prefix(){return g.getPrefix()},get runtime(){return g.getRuntimeName()},get suffix(){return g.getSuffix()}};try{self.workbox.v=self.workbox.v||{}}catch{}return h._private=T,h.clientsClaim=()=>{addEventListener("activate",()=>clients.claim())},h.cacheNames=C,h.registerQuotaErrorCallback=function(e){b.add(e)},h.setCacheNameDetails=e=>{g.updateDetails(e)},h.skipWaiting=()=>{addEventListener("install",()=>self.skipWaiting())},h}({});
