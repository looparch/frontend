this.workbox=this.workbox||{},this.workbox.strategies=function(h,n,p,g,u,d,k,w){"use strict";try{self["workbox:strategies:4.3.1"]&&_()}catch{}const U=i=>{const e=new URL(i,location);return e.origin===location.origin?e.pathname:e.href},l={strategyStart:(i,e)=>`Using ${i} to respond to '${U(e.url)}'`,printFinalResponse:i=>{i&&(n.logger.groupCollapsed("View the final response here."),n.logger.log(i),n.logger.groupEnd())}};class y{constructor(e={}){this._cacheName=g.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const a=[];typeof t=="string"&&(t=new Request(t)),p.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"CacheFirst",funcName:"makeRequest",paramName:"request"});let s=await u.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins}),r;if(s)a.push(`Found a cached response in the '${this._cacheName}' cache.`);else{a.push(`No response found in the '${this._cacheName}' cache. Will respond with a network request.`);try{s=await this._getFromNetwork(t,e)}catch(o){r=o}s?a.push("Got response from network."):a.push("Unable to get a response from the network.")}{n.logger.groupCollapsed(l.strategyStart("CacheFirst",t));for(let o of a)n.logger.log(o);l.printFinalResponse(s),n.logger.groupEnd()}if(!s)throw new w.WorkboxError("no-response",{url:t.url,error:r});return s}async _getFromNetwork(e,t){const a=await d.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),s=a.clone(),r=u.cacheWrapper.put({cacheName:this._cacheName,request:e,response:s,event:t,plugins:this._plugins});if(t)try{t.waitUntil(r)}catch{n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${k.getFriendlyURL(e.url)}'.`)}return a}}class O{constructor(e={}){this._cacheName=g.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._matchOptions=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){typeof t=="string"&&(t=new Request(t)),p.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"CacheOnly",funcName:"makeRequest",paramName:"request"});const a=await u.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins});if(n.logger.groupCollapsed(l.strategyStart("CacheOnly",t)),a?(n.logger.log(`Found a cached response in the '${this._cacheName}' cache.`),l.printFinalResponse(a)):n.logger.log(`No response found in the '${this._cacheName}' cache.`),n.logger.groupEnd(),!a)throw new w.WorkboxError("no-response",{url:t.url});return a}}const N={cacheWillUpdate:({response:i})=>i.status===200||i.status===0?i:null};class R{constructor(e={}){if(this._cacheName=g.cacheNames.getRuntimeName(e.cacheName),e.plugins){let t=e.plugins.some(a=>!!a.cacheWillUpdate);this._plugins=t?e.plugins:[N,...e.plugins]}else this._plugins=[N];this._networkTimeoutSeconds=e.networkTimeoutSeconds,this._networkTimeoutSeconds&&p.assert.isType(this._networkTimeoutSeconds,"number",{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"constructor",paramName:"networkTimeoutSeconds"}),this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const a=[];typeof t=="string"&&(t=new Request(t)),p.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"NetworkFirst",funcName:"handle",paramName:"makeRequest"});const s=[];let r;if(this._networkTimeoutSeconds){const{id:f,promise:C}=this._getTimeoutPromise({request:t,event:e,logs:a});r=f,s.push(C)}const o=this._getNetworkPromise({timeoutId:r,request:t,event:e,logs:a});s.push(o);let c=await Promise.race(s);c||(c=await o);{n.logger.groupCollapsed(l.strategyStart("NetworkFirst",t));for(let f of a)n.logger.log(f);l.printFinalResponse(c),n.logger.groupEnd()}if(!c)throw new w.WorkboxError("no-response",{url:t.url});return c}_getTimeoutPromise({request:e,logs:t,event:a}){let s;return{promise:new Promise(o=>{s=setTimeout(async()=>{t.push(`Timing out the network response at ${this._networkTimeoutSeconds} seconds.`),o(await this._respondFromCache({request:e,event:a}))},this._networkTimeoutSeconds*1e3)}),id:s}}async _getNetworkPromise({timeoutId:e,request:t,logs:a,event:s}){let r,o;try{o=await d.fetchWrapper.fetch({request:t,event:s,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(c){r=c}if(e&&clearTimeout(e),o?a.push("Got response from network."):a.push("Unable to get a response from the network. Will respond with a cached response."),r||!o)o=await this._respondFromCache({request:t,event:s}),o?a.push(`Found a cached response in the '${this._cacheName}' cache.`):a.push(`No response found in the '${this._cacheName}' cache.`);else{const c=o.clone(),f=u.cacheWrapper.put({cacheName:this._cacheName,request:t,response:c,event:s,plugins:this._plugins});if(s)try{s.waitUntil(f)}catch{n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${k.getFriendlyURL(t.url)}'.`)}}return o}_respondFromCache({event:e,request:t}){return u.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins})}}class F{constructor(e={}){this._cacheName=g.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],this._fetchOptions=e.fetchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){typeof t=="string"&&(t=new Request(t)),p.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"NetworkOnly",funcName:"handle",paramName:"request"});let a,s;try{s=await d.fetchWrapper.fetch({request:t,event:e,fetchOptions:this._fetchOptions,plugins:this._plugins})}catch(r){a=r}if(n.logger.groupCollapsed(l.strategyStart("NetworkOnly",t)),s?n.logger.log("Got response from network."):n.logger.log("Unable to get a response from the network."),l.printFinalResponse(s),n.logger.groupEnd(),!s)throw new w.WorkboxError("no-response",{url:t.url,error:a});return s}}class b{constructor(e={}){if(this._cacheName=g.cacheNames.getRuntimeName(e.cacheName),this._plugins=e.plugins||[],e.plugins){let t=e.plugins.some(a=>!!a.cacheWillUpdate);this._plugins=t?e.plugins:[N,...e.plugins]}else this._plugins=[N];this._fetchOptions=e.fetchOptions||null,this._matchOptions=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const a=[];typeof t=="string"&&(t=new Request(t)),p.assert.isInstance(t,Request,{moduleName:"workbox-strategies",className:"StaleWhileRevalidate",funcName:"handle",paramName:"request"});const s=this._getFromNetwork({request:t,event:e});let r=await u.cacheWrapper.match({cacheName:this._cacheName,request:t,event:e,matchOptions:this._matchOptions,plugins:this._plugins}),o;if(r){if(a.push(`Found a cached response in the '${this._cacheName}' cache. Will update with the network response in the background.`),e)try{e.waitUntil(s)}catch{n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${k.getFriendlyURL(t.url)}'.`)}}else{a.push(`No response found in the '${this._cacheName}' cache. Will wait for the network response.`);try{r=await s}catch(c){o=c}}{n.logger.groupCollapsed(l.strategyStart("StaleWhileRevalidate",t));for(let c of a)n.logger.log(c);l.printFinalResponse(r),n.logger.groupEnd()}if(!r)throw new w.WorkboxError("no-response",{url:t.url,error:o});return r}async _getFromNetwork({request:e,event:t}){const a=await d.fetchWrapper.fetch({request:e,event:t,fetchOptions:this._fetchOptions,plugins:this._plugins}),s=u.cacheWrapper.put({cacheName:this._cacheName,request:e,response:a.clone(),event:t,plugins:this._plugins});if(t)try{t.waitUntil(s)}catch{n.logger.warn(`Unable to ensure service worker stays alive when updating cache for '${k.getFriendlyURL(e.url)}'.`)}return a}}const W={cacheFirst:y,cacheOnly:O,networkFirst:R,networkOnly:F,staleWhileRevalidate:b},m=i=>{const e=W[i];return t=>{{const a=i[0].toUpperCase()+i.slice(1);n.logger.warn(`The 'workbox.strategies.${i}()' function has been deprecated and will be removed in a future version of Workbox.
Please use 'new workbox.strategies.${a}()' instead.`)}return new e(t)}},S=m("cacheFirst"),P=m("cacheOnly"),T=m("networkFirst"),$=m("networkOnly"),x=m("staleWhileRevalidate");return h.CacheFirst=y,h.CacheOnly=O,h.NetworkFirst=R,h.NetworkOnly=F,h.StaleWhileRevalidate=b,h.cacheFirst=S,h.cacheOnly=P,h.networkFirst=T,h.networkOnly=$,h.staleWhileRevalidate=x,h}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
