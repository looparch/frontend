this.workbox=this.workbox||{},this.workbox.backgroundSync=function(d,y,o,r,h,p){"use strict";try{self["workbox:background-sync:4.3.1"]&&_()}catch{}const m=3,N="workbox-background-sync",n="requests",c="queueName";class R{constructor(e){this._queueName=e,this._db=new p.DBWrapper(N,m,{onupgradeneeded:this._upgradeDb})}async pushEntry(e){r.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry"}),r.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"pushEntry",paramName:"entry.requestData"}),delete e.id,e.queueName=this._queueName,await this._db.add(n,e)}async unshiftEntry(e){r.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry"}),r.assert.isType(e.requestData,"object",{moduleName:"workbox-background-sync",className:"QueueStore",funcName:"unshiftEntry",paramName:"entry.requestData"});const[t]=await this._db.getAllMatching(n,{count:1});t?e.id=t.id-1:delete e.id,e.queueName=this._queueName,await this._db.add(n,e)}async popEntry(){return this._removeEntry({direction:"prev"})}async shiftEntry(){return this._removeEntry({direction:"next"})}async getAll(){return await this._db.getAllMatching(n,{index:c,query:IDBKeyRange.only(this._queueName)})}async deleteEntry(e){await this._db.delete(n,e)}async _removeEntry({direction:e}){const[t]=await this._db.getAllMatching(n,{direction:e,index:c,query:IDBKeyRange.only(this._queueName),count:1});if(t)return await this.deleteEntry(t.id),t}_upgradeDb(e){const t=e.target.result;e.oldVersion>0&&e.oldVersion<m&&t.objectStoreNames.contains(n)&&t.deleteObjectStore(n),t.createObjectStore(n,{autoIncrement:!0,keyPath:"id"}).createIndex(c,c,{unique:!1})}}const k=["method","referrer","referrerPolicy","mode","credentials","cache","redirect","integrity","keepalive"];class u{static async fromRequest(e){const t={url:e.url,headers:{}};e.method!=="GET"&&(t.body=await e.clone().arrayBuffer());for(const[s,a]of e.headers.entries())t.headers[s]=a;for(const s of k)e[s]!==void 0&&(t[s]=e[s]);return new u(t)}constructor(e){r.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData"}),r.assert.isType(e.url,"string",{moduleName:"workbox-background-sync",className:"StorableRequest",funcName:"constructor",paramName:"requestData.url"}),e.mode==="navigate"&&(e.mode="same-origin"),this._requestData=e}toObject(){const e=Object.assign({},this._requestData);return e.headers=Object.assign({},this._requestData.headers),e.body&&(e.body=e.body.slice(0)),e}toRequest(){return new Request(this._requestData.url,this._requestData)}clone(){return new u(this.toObject())}}const b="workbox-background-sync",E=60*24*7,l=new Set;class q{constructor(e,{onSync:t,maxRetentionTime:s}={}){if(l.has(e))throw new y.WorkboxError("duplicate-queue-name",{name:e});l.add(e),this._name=e,this._onSync=t||this.replayRequests,this._maxRetentionTime=s||E,this._queueStore=new R(this._name),this._addSyncListener()}get name(){return this._name}async pushRequest(e){r.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry"}),r.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"pushRequest",paramName:"entry.request"}),await this._addRequest(e,"push")}async unshiftRequest(e){r.assert.isType(e,"object",{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry"}),r.assert.isInstance(e.request,Request,{moduleName:"workbox-background-sync",className:"Queue",funcName:"unshiftRequest",paramName:"entry.request"}),await this._addRequest(e,"unshift")}async popRequest(){return this._removeRequest("pop")}async shiftRequest(){return this._removeRequest("shift")}async getAll(){const e=await this._queueStore.getAll(),t=Date.now(),s=[];for(const a of e){const g=this._maxRetentionTime*60*1e3;t-a.timestamp>g?await this._queueStore.deleteEntry(a.id):s.push(f(a))}return s}async _addRequest({request:e,metadata:t,timestamp:s=Date.now()},a){const w={requestData:(await u.fromRequest(e.clone())).toObject(),timestamp:s};t&&(w.metadata=t),await this._queueStore[`${a}Entry`](w),o.logger.log(`Request for '${h.getFriendlyURL(e.url)}' has been added to background sync queue '${this._name}'.`),this._syncInProgress?this._requestsAddedDuringSync=!0:await this.registerSync()}async _removeRequest(e){const t=Date.now(),s=await this._queueStore[`${e}Entry`]();if(s){const a=this._maxRetentionTime*60*1e3;return t-s.timestamp>a?this._removeRequest(e):f(s)}}async replayRequests(){let e;for(;e=await this.shiftRequest();)try{await fetch(e.request.clone()),o.logger.log(`Request for '${h.getFriendlyURL(e.request.url)}'has been replayed in queue '${this._name}'`)}catch{throw await this.unshiftRequest(e),o.logger.log(`Request for '${h.getFriendlyURL(e.request.url)}'failed to replay, putting it back in queue '${this._name}'`),new y.WorkboxError("queue-replay-failed",{name:this._name})}o.logger.log(`All requests in queue '${this.name}' have successfully replayed; the queue is now empty!`)}async registerSync(){if("sync"in registration)try{await registration.sync.register(`${b}:${this._name}`)}catch(e){o.logger.warn(`Unable to register sync event for '${this._name}'.`,e)}}_addSyncListener(){"sync"in registration?self.addEventListener("sync",e=>{if(e.tag===`${b}:${this._name}`){o.logger.log(`Background sync for tag '${e.tag}'has been received`);const t=async()=>{this._syncInProgress=!0;let s;try{await this._onSync({queue:this})}catch(a){throw s=a,s}finally{this._requestsAddedDuringSync&&!(s&&!e.lastChance)&&await this.registerSync(),this._syncInProgress=!1,this._requestsAddedDuringSync=!1}};e.waitUntil(t())}}):(o.logger.log("Background sync replaying without background sync event"),this._onSync({queue:this}))}static get _queueNames(){return l}}const f=i=>{const e={request:new u(i.requestData).toRequest(),timestamp:i.timestamp};return i.metadata&&(e.metadata=i.metadata),e};class x{constructor(...e){this._queue=new q(...e),this.fetchDidFail=this.fetchDidFail.bind(this)}async fetchDidFail({request:e}){await this._queue.pushRequest({request:e})}}return d.Queue=q,d.Plugin=x,d}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
