this.workbox=this.workbox||{},this.workbox.precaching=function(h,f,g,w,n,T,m,p){"use strict";try{self["workbox:precaching:4.3.1"]&&_()}catch{}const R=[],C={get(){return R},add(t){R.push(...t)}},N=t=>{C.add(t)};async function k(t){const e=t.clone(),c=await("body"in e?Promise.resolve(e.body):e.blob());return new Response(c,{headers:e.headers,status:e.status,statusText:e.statusText})}const v="__WB_REVISION__";function E(t){if(!t)throw new p.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if(typeof t=="string"){const o=new URL(t,location);return{cacheKey:o.href,url:o.href}}const{revision:e,url:a}=t;if(!a)throw new p.WorkboxError("add-to-cache-list-unexpected-type",{entry:t});if(!e){const o=new URL(a,location);return{cacheKey:o.href,url:o.href}}const c=new URL(a,location),r=new URL(a,location);return r.searchParams.set(v,e),{cacheKey:r.href,url:c.href}}const x=(t,e)=>{n.logger.groupCollapsed(t);for(const a of e)n.logger.log(a);n.logger.groupEnd()};function q(t){const e=t.length;e>0&&(n.logger.groupCollapsed(`During precaching cleanup, ${e} cached request${e===1?" was":"s were"} deleted.`),x("Deleted Cache Requests",t),n.logger.groupEnd())}function L(t,e){if(e.length!==0){n.logger.groupCollapsed(t);for(const a of e)n.logger.log(a);n.logger.groupEnd()}}function S(t,e){const a=t.length,c=e.length;if(a||c){let r=`Precaching ${a} file${a===1?"":"s"}.`;c>0&&(r+=` ${c} file${c===1?" is":"s are"} already cached.`),n.logger.groupCollapsed(r),L("View newly precached URLs.",t),L("View previously precached URLs.",e),n.logger.groupEnd()}}class U{constructor(e){this._cacheName=g.cacheNames.getPrecacheName(e),this._urlsToCacheKeys=new Map}addToCacheList(e){f.assert.isArray(e,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"addToCacheList",paramName:"entries"});for(const a of e){const{cacheKey:c,url:r}=E(a);if(this._urlsToCacheKeys.has(r)&&this._urlsToCacheKeys.get(r)!==c)throw new p.WorkboxError("add-to-cache-list-conflicting-entries",{firstEntry:this._urlsToCacheKeys.get(r),secondEntry:c});this._urlsToCacheKeys.set(r,c)}}async install({event:e,plugins:a}={}){a&&f.assert.isArray(a,{moduleName:"workbox-precaching",className:"PrecacheController",funcName:"install",paramName:"plugins"});const c=[],r=[],s=await(await caches.open(this._cacheName)).keys(),l=new Set(s.map(u=>u.url));for(const u of this._urlsToCacheKeys.values())l.has(u)?r.push(u):c.push(u);const i=c.map(u=>this._addURLToCache({event:e,plugins:a,url:u}));return await Promise.all(i),S(c,r),{updatedURLs:c,notUpdatedURLs:r}}async activate(){const e=await caches.open(this._cacheName),a=await e.keys(),c=new Set(this._urlsToCacheKeys.values()),r=[];for(const o of a)c.has(o.url)||(await e.delete(o),r.push(o.url));return q(r),{deletedURLs:r}}async _addURLToCache({url:e,event:a,plugins:c}){const r=new Request(e,{credentials:"same-origin"});let o=await m.fetchWrapper.fetch({event:a,plugins:c,request:r}),s;for(const i of c||[])"cacheWillUpdate"in i&&(s=i.cacheWillUpdate.bind(i));if(!(s?s({event:a,request:r,response:o}):o.status<400))throw new p.WorkboxError("bad-precaching-response",{url:e,status:o.status});o.redirected&&(o=await k(o)),await T.cacheWrapper.put({event:a,plugins:c,request:r,response:o,cacheName:this._cacheName,matchOptions:{ignoreSearch:!0}})}getURLsToCacheKeys(){return this._urlsToCacheKeys}getCachedURLs(){return[...this._urlsToCacheKeys.keys()]}getCacheKeyForURL(e){const a=new URL(e,location);return this._urlsToCacheKeys.get(a.href)}}let y;const d=()=>(y||(y=new U),y);function W(t,e){for(const a of[...t.searchParams.keys()])e.some(c=>c.test(a))&&t.searchParams.delete(a);return t}function*O(t,{ignoreURLParametersMatching:e,directoryIndex:a,cleanURLs:c,urlManipulation:r}={}){const o=new URL(t,location);o.hash="",yield o.href;const s=W(o,e);if(yield s.href,a&&s.pathname.endsWith("/")){const l=new URL(s);l.pathname+=a,yield l.href}if(c){const l=new URL(s);l.pathname+=".html",yield l.href}if(r){const l=r({url:o});for(const i of l)yield i.href}}const $=(t,e)=>{const c=d().getURLsToCacheKeys();for(const r of O(t,e)){const o=c.get(r);if(o)return o}},A=({ignoreURLParametersMatching:t=[/^utm_/],directoryIndex:e="index.html",cleanURLs:a=!0,urlManipulation:c=null}={})=>{const r=g.cacheNames.getPrecacheName();addEventListener("fetch",o=>{const s=$(o.request.url,{cleanURLs:a,directoryIndex:e,ignoreURLParametersMatching:t,urlManipulation:c});if(!s){n.logger.debug("Precaching did not find a match for "+w.getFriendlyURL(o.request.url));return}let l=caches.open(r).then(i=>i.match(s)).then(i=>i||(n.logger.warn(`The precached response for ${w.getFriendlyURL(s)} in ${r} was not found. Falling back to the network instead.`),fetch(s)));l=l.then(i=>(n.logger.groupCollapsed("Precaching is responding to: "+w.getFriendlyURL(o.request.url)),n.logger.log(`Serving the precached url: ${s}`),n.logger.groupCollapsed("View request details here."),n.logger.log(o.request),n.logger.groupEnd(),n.logger.groupCollapsed("View response details here."),n.logger.log(i),n.logger.groupEnd(),n.logger.groupEnd(),i)),o.respondWith(l)})};let b=!1;const K=t=>{b||(A(t),b=!0)},F="-precache-",I=async(t,e=F)=>{const c=(await caches.keys()).filter(r=>r.includes(e)&&r.includes(self.registration.scope)&&r!==t);return await Promise.all(c.map(r=>caches.delete(r))),c},V=()=>{addEventListener("activate",t=>{const e=g.cacheNames.getPrecacheName();t.waitUntil(I(e).then(a=>{a.length>0&&n.logger.log("The following out-of-date precaches were cleaned up automatically:",a)}))})},D=t=>d().getCacheKeyForURL(t),G=t=>{const e=d(),a=C.get();t.waitUntil(e.install({event:t,plugins:a}).catch(c=>{throw n.logger.error("Service worker installation failed. It will be retried automatically during the next navigation."),c}))},B=t=>{const e=d(),a=C.get();t.waitUntil(e.activate({event:t,plugins:a}))},P=t=>{d().addToCacheList(t),t.length>0&&(addEventListener("install",G),addEventListener("activate",B))},H=(t,e)=>{P(t),K(e)};return f.assert.isSWEnv("workbox-precaching"),h.addPlugins=N,h.addRoute=K,h.cleanupOutdatedCaches=V,h.getCacheKeyForURL=D,h.precache=P,h.precacheAndRoute=H,h.PrecacheController=U,h}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
