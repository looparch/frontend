this.workbox=this.workbox||{},this.workbox.strategies=function(a,o,u,m,l){"use strict";try{self["workbox:strategies:4.3.1"]&&_()}catch{}class v{constructor(e={}){this.t=o.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){typeof t=="string"&&(t=new Request(t));let r,s=await u.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!s)try{s=await this.u(t,e)}catch(n){r=n}if(!s)throw new l.WorkboxError("no-response",{url:t.url,error:r});return s}async u(e,t){const r=await m.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),s=r.clone(),n=u.cacheWrapper.put({cacheName:this.t,request:e,response:s,event:t,plugins:this.s});if(t)try{t.waitUntil(n)}catch{}return r}}class g{constructor(e={}){this.t=o.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){typeof t=="string"&&(t=new Request(t));const r=await u.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(!r)throw new l.WorkboxError("no-response",{url:t.url});return r}}const q={cacheWillUpdate:({response:c})=>c.status===200||c.status===0?c:null};class f{constructor(e={}){if(this.t=o.cacheNames.getRuntimeName(e.cacheName),e.plugins){let t=e.plugins.some(r=>!!r.cacheWillUpdate);this.s=t?e.plugins:[q,...e.plugins]}else this.s=[q];this.o=e.networkTimeoutSeconds,this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const r=[];typeof t=="string"&&(t=new Request(t));const s=[];let n;if(this.o){const{id:w,promise:N}=this.l({request:t,event:e,logs:r});n=w,s.push(N)}const i=this.q({timeoutId:n,request:t,event:e,logs:r});s.push(i);let h=await Promise.race(s);if(h||(h=await i),!h)throw new l.WorkboxError("no-response",{url:t.url});return h}l({request:e,logs:t,event:r}){let s;return{promise:new Promise(n=>{s=setTimeout(async()=>{n(await this.p({request:e,event:r}))},1e3*this.o)}),id:s}}async q({timeoutId:e,request:t,logs:r,event:s}){let n,i;try{i=await m.fetchWrapper.fetch({request:t,event:s,fetchOptions:this.i,plugins:this.s})}catch(h){n=h}if(e&&clearTimeout(e),n||!i)i=await this.p({request:t,event:s});else{const h=i.clone(),w=u.cacheWrapper.put({cacheName:this.t,request:t,response:h,event:s,plugins:this.s});if(s)try{s.waitUntil(w)}catch{}}return i}p({event:e,request:t}){return u.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s})}}class y{constructor(e={}){this.t=o.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],this.i=e.fetchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){let r,s;typeof t=="string"&&(t=new Request(t));try{s=await m.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.i,plugins:this.s})}catch(n){r=n}if(!s)throw new l.WorkboxError("no-response",{url:t.url,error:r});return s}}class k{constructor(e={}){if(this.t=o.cacheNames.getRuntimeName(e.cacheName),this.s=e.plugins||[],e.plugins){let t=e.plugins.some(r=>!!r.cacheWillUpdate);this.s=t?e.plugins:[q,...e.plugins]}else this.s=[q];this.i=e.fetchOptions||null,this.h=e.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){typeof t=="string"&&(t=new Request(t));const r=this.u({request:t,event:e});let s,n=await u.cacheWrapper.match({cacheName:this.t,request:t,event:e,matchOptions:this.h,plugins:this.s});if(n){if(e)try{e.waitUntil(r)}catch{}}else try{n=await r}catch(i){s=i}if(!n)throw new l.WorkboxError("no-response",{url:t.url,error:s});return n}async u({request:e,event:t}){const r=await m.fetchWrapper.fetch({request:e,event:t,fetchOptions:this.i,plugins:this.s}),s=u.cacheWrapper.put({cacheName:this.t,request:e,response:r.clone(),event:t,plugins:this.s});if(t)try{t.waitUntil(s)}catch{}return r}}const O={cacheFirst:v,cacheOnly:g,networkFirst:f,networkOnly:y,staleWhileRevalidate:k},p=c=>{const e=O[c];return t=>new e(t)},R=p("cacheFirst"),W=p("cacheOnly"),d=p("networkFirst"),b=p("networkOnly"),x=p("staleWhileRevalidate");return a.CacheFirst=v,a.CacheOnly=g,a.NetworkFirst=f,a.NetworkOnly=y,a.StaleWhileRevalidate=k,a.cacheFirst=R,a.cacheOnly=W,a.networkFirst=d,a.networkOnly=b,a.staleWhileRevalidate=x,a}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);
