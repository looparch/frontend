this.workbox=this.workbox||{},this.workbox.routing=function(a,R,d){"use strict";try{self["workbox:routing:4.3.1"]&&_()}catch{}const b="GET",f=o=>o&&typeof o=="object"?o:{handle:o};class h{constructor(e,r,t){this.handler=f(r),this.match=e,this.method=t||b}}class m extends h{constructor(e,{whitelist:r=[/./],blacklist:t=[]}={}){super(s=>this.t(s),e),this.s=r,this.o=t}t({url:e,request:r}){if(r.mode!=="navigate")return!1;const t=e.pathname+e.search;for(const s of this.o)if(s.test(t))return!1;return!!this.s.some(s=>s.test(t))}}class p extends h{constructor(e,r,t){super(({url:s})=>{const n=e.exec(s.href);return n?s.origin!==location.origin&&n.index!==0?null:n.slice(1):null},r,t)}}class w{constructor(){this.i=new Map}get routes(){return this.i}addFetchListener(){self.addEventListener("fetch",e=>{const{request:r}=e,t=this.handleRequest({request:r,event:e});t&&e.respondWith(t)})}addCacheListener(){self.addEventListener("message",async e=>{if(e.data&&e.data.type==="CACHE_URLS"){const{payload:r}=e.data,t=Promise.all(r.urlsToCache.map(s=>{typeof s=="string"&&(s=[s]);const n=new Request(...s);return this.handleRequest({request:n})}));e.waitUntil(t),e.ports&&e.ports[0]&&(await t,e.ports[0].postMessage(!0))}})}handleRequest({request:e,event:r}){const t=new URL(e.url,location);if(!t.protocol.startsWith("http"))return;let s,{params:n,route:c}=this.findMatchingRoute({url:t,request:e,event:r}),i=c&&c.handler;if(!i&&this.u&&(i=this.u),i){try{s=i.handle({url:t,request:e,event:r,params:n})}catch(g){s=Promise.reject(g)}return s&&this.h&&(s=s.catch(g=>this.h.handle({url:t,event:r,err:g}))),s}}findMatchingRoute({url:e,request:r,event:t}){const s=this.i.get(r.method)||[];for(const n of s){let c,i=n.match({url:e,request:r,event:t});if(i)return(Array.isArray(i)&&i.length>0||i.constructor===Object&&Object.keys(i).length>0)&&(c=i),{route:n,params:c}}return{}}setDefaultHandler(e){this.u=f(e)}setCatchHandler(e){this.h=f(e)}registerRoute(e){this.i.has(e.method)||this.i.set(e.method,[]),this.i.get(e.method).push(e)}unregisterRoute(e){if(!this.i.has(e.method))throw new d.WorkboxError("unregister-route-but-not-found-with-method",{method:e.method});const r=this.i.get(e.method).indexOf(e);if(!(r>-1))throw new d.WorkboxError("unregister-route-route-not-registered");this.i.get(e.method).splice(r,1)}}let u;const l=()=>(u||((u=new w).addFetchListener(),u.addCacheListener()),u);return a.NavigationRoute=m,a.RegExpRoute=p,a.registerNavigationRoute=(o,e={})=>{const r=R.cacheNames.getPrecacheName(e.cacheName),t=new m(async()=>{try{const s=await caches.match(o,{cacheName:r});if(s)return s;throw new Error(`The cache ${r} did not have an entry for ${o}.`)}catch{return fetch(o)}},{whitelist:e.whitelist,blacklist:e.blacklist});return l().registerRoute(t),t},a.registerRoute=(o,e,r="GET")=>{let t;if(typeof o=="string"){const s=new URL(o,location);t=new h(({url:n})=>n.href===s.href,e,r)}else if(o instanceof RegExp)t=new p(o,e,r);else if(typeof o=="function")t=new h(o,e,r);else{if(!(o instanceof h))throw new d.WorkboxError("unsupported-route-type",{moduleName:"workbox-routing",funcName:"registerRoute",paramName:"capture"});t=o}return l().registerRoute(t),t},a.Route=h,a.Router=w,a.setCatchHandler=o=>{l().setCatchHandler(o)},a.setDefaultHandler=o=>{l().setDefaultHandler(o)},a}({},workbox.core._private,workbox.core._private);
